piv0t is a deterministic, state-based substitution cipher designed as a "Human-Proof-of-Work" system. Unlike standard ciphers that use a static key or a simple shifting table, piv0t re-calculates its entire mathematical logic gate for every character processed. It is logically deterministic but computationally expensive.

The system is governed by a Seed ID consisting of a digit ($n$) and a letter ($L$). This ID represents the current state of the machine. As each character is encoded or decoded, the ID mutates, ensuring that the same plaintext letter never results in the same ciphertext letter twice in a row.

The machine begins by converting the plaintext letter to its position ($P$) in the alphabet (A=1, Z=26).
*   Base Generation: The system squares the current ID number ($n$) and adds the $L$-th number of the Fibonacci sequence.
*   Expansion: The base is raised to the power of the plaintext position ($Base^P$). 
*   The Bounce: A modulo 26 operation is applied. If the result is 25 or 0/26, the "Bounce" is triggered, causing the alphabet to fold back on itself (e.g., $26 - R$). This prevents standard linear frequency analysis.

Layer 2 introduces non-linear dispersal to obscure the mathematical relationship between the expanded integer and the output.
*   The Sieve: The encoder sums the digits of the Expanded Integer ($Base^P$) located at non-prime positions (1, 4, 6, 8, etc.) to create a Dynamic Multiplier ($S$).
*   Persistence Pivot: The system calculates the recursive digit sum (Persistence $k$) of the current ID number. The Layer 1 result is scaled by $k$ and shifted by the ID letter position to create the **Pivot Value ($V$)**.

The final layer applies modular group theory and irrational constants to ensure the cipher is resistant to brute-force attacks.
*   Modular Inverse: The machine finds the modular multiplicative inverse of the ID Persistence ($k$) modulo 26.
*   Transcendental Sieve: The system uses the last two digits of the Expanded Integer as a pointer to extract a specific digit from the first 100 digits of $\pi$. This "Shift-Salt" ($\tau$) is added to the inverted pivot.
*   Digit-Root Loop: The resulting value is subjected to a nested power-summation loop. The value is raised to the power of the ID's first digit, and its digit root is extracted. This process repeats for $L$ iterations.
*   Prime Anchor Reflection: The final value "bounces" off the largest prime number strictly less than the current ID number to produce the final ciphertext character.

After a character is produced, the ID state is destroyed and rebuilt:
*   Numeric Mutation: $n_{next} = (n_{prev} \times P) \pmod{100}$.
*   Alphabetic Mutation: $L_{next} = (L_{prev} + CiphertextValue) \pmod{26}$.

*   Sensitivity to Initial Conditions: A single digit change in the Seed ID results in a completely different ciphertext after just one character due to the $Base^P$ expansion.
*   Computational Hardness: Deciphering requires the recipient to replicate the state machine perfectly. Without the Seed ID, an attacker must brute-force 26 possibilities for every character while simultaneously tracking a shifting state.
*   Non-Linearity: The combination of the "Bounce," the $\pi$-sieve, and the Digit-Root loop ensures that the relationship between plaintext and ciphertext is non-arithmetic.
